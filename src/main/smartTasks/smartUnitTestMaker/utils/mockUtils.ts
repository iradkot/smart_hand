import fs from 'fs';
import path from 'path';
import { MockDefinition } from '../types/flows';
import { generateTestFile } from 'src/api/requests/aiOperationsRequests';

/**
 * Creates or finds the mocks directory for a project.
 * Creates nested mock directories if needed.
 */
export const setupMocksDirectory = (projectPath: string, modulePath: string): string => {
  // Create base mocks directory
  const baseDir = path.join(projectPath, '__mocks__');
  if (!fs.existsSync(baseDir)) {
    fs.mkdirSync(baseDir, { recursive: true });
  }

  // Handle scoped packages and nested modules
  if (modulePath.startsWith('@') || modulePath.includes('/')) {
    const mockDir = path.join(baseDir, path.dirname(modulePath));
    fs.mkdirSync(mockDir, { recursive: true });
  }

  return baseDir;
};

/**
 * Enhanced mock search that integrates local and AI operations
 */
export const findOrCreateMock = async (
  sessionId: string,
  projectPath: string, 
  modulePath: string,
  originalContent?: string,
  complexityMetrics?: any
): Promise<MockDefinition> => {
  // First try local operations
  const existingMock = findExistingMock(projectPath, modulePath);
  if (existingMock) {
    // Start with local validation
    const basicValidation = await validateMockContent(existingMock, originalContent);
    if (basicValidation.isValid && !basicValidation.needsEnhancement) {
      return existingMock;
    }

    // If the mock needs enhancement, use AI to improve it
    if (basicValidation.needsEnhancement && sessionId) {
      const enhancedMock = await enhanceExistingMock(
        sessionId,
        existingMock,
        originalContent,
        basicValidation.missingFeatures
      );
      if (enhancedMock) return enhancedMock;
    }
  }

  // Generate new mock with integrated approach
  const mockContent = await generateMockContent(sessionId, modulePath, originalContent, complexityMetrics);
  return createMockFile(projectPath, modulePath, mockContent);
};

interface ValidationResult {
  isValid: boolean;
  needsEnhancement: boolean;
  missingFeatures?: string[];
}

/**
 * Validates mock content with both local and AI assistance
 */
const validateMockContent = async (
  mock: MockDefinition, 
  originalContent?: string
): Promise<ValidationResult | boolean> => {
  if (!originalContent) return { isValid: true, needsEnhancement: false };

  try {
    const mockContent = await fs.promises.readFile(mock.mockPath, 'utf8');
    
    // Local validation first
    const hasAllExports = validateExports(mockContent, originalContent);
    const hasValidSyntax = validateMockSyntax(mockContent);
    const hasDependencies = validateDependencies(mock);

    // Check for enhancement needs
    const missingFeatures = [];
    if (!mockContent.includes('mockImplementation')) missingFeatures.push('mockImplementation');
    if (!mockContent.includes('jest.spyOn')) missingFeatures.push('spies');
    if (originalContent.includes('async') && !mockContent.includes('mockResolvedValue')) {
      missingFeatures.push('asyncMocking');
    }

    const validationResult = {
      isValid: hasAllExports && hasValidSyntax && hasDependencies,
      needsEnhancement: missingFeatures.length > 0,
      missingFeatures
    };

    return validationResult;
  } catch (error) {
    return false;
  }
};

/**
 * Uses AI to enhance an existing mock
 */
const enhanceExistingMock = async (
  sessionId: string,
  mock: MockDefinition,
  originalContent: string | undefined,
  missingFeatures: string[]
): Promise<MockDefinition | null> => {
  try {
    const mockContent = await fs.promises.readFile(mock.mockPath, 'utf8');
    const enhancementPrompt = `
Enhance this Jest mock to include: ${missingFeatures.join(', ')}

Original mock:
\`\`\`typescript
${mockContent}
\`\`\`

${originalContent ? `Original module for reference:
\`\`\`typescript
${originalContent}
\`\`\`` : ''}
`;

    const aiResponse = await generateTestFile(sessionId, mock.modulePath, enhancementPrompt);
    await fs.promises.writeFile(mock.mockPath, aiResponse.content.testCode);

    return {
      ...mock,
      isAutoGenerated: true
    };
  } catch (error) {
    return null;
  }
};

/**
 * Generates mock content using both local analysis and AI
 */
const generateMockContent = async (
  sessionId: string,
  modulePath: string,
  originalContent?: string,
  complexityMetrics?: any
): Promise<string> => {
  const basePrompt = buildMockPrompt(modulePath, originalContent);
  
  // Add complexity-based considerations
  const complexitySection = complexityMetrics ? `
Consider these complexity factors:
${complexityMetrics.hasAsyncOperations ? '- Include async mock implementations' : ''}
${complexityMetrics.hasStateManagement ? '- Mock state management functions' : ''}
${complexityMetrics.hasEventHandling ? '- Include event handling mocks' : ''}
${complexityMetrics.importComplexity > 0 ? '- Handle complex import patterns' : ''}
` : '';

  const fullPrompt = basePrompt + complexitySection;
  const aiResponse = await generateTestFile(sessionId, modulePath, fullPrompt);
  return aiResponse.content.testCode;
};

/**
 * Searches for existing mock files in the project
 */
export const findExistingMock = (projectPath: string, modulePath: string): MockDefinition | null => {
  const baseDir = path.join(projectPath, '__mocks__');
  if (!fs.existsSync(baseDir)) return null;

  // Handle scoped packages and local imports
  const mockRelativePath = modulePath.startsWith('.') 
    ? path.relative(projectPath, path.resolve(projectPath, modulePath))
    : modulePath;

  const mockFileName = `${path.basename(mockRelativePath, path.extname(mockRelativePath))}.mock${path.extname(mockRelativePath) || '.ts'}`;
  const mockPath = path.join(baseDir, path.dirname(mockRelativePath), mockFileName);

  if (fs.existsSync(mockPath)) {
    // Read the mock file to check for dependencies
    const mockContent = fs.readFileSync(mockPath, 'utf8');
    const dependencies = extractMockDependencies(mockContent);

    return {
      modulePath,
      mockPath,
      isAutoGenerated: false,
      dependencies
    };
  }

  return null;
};

/**
 * Validates that mock has all necessary exports
 */
const validateExports = (mockContent: string, originalContent: string): boolean => {
  const originalExports = extractExports(originalContent);
  const mockExports = extractExports(mockContent);

  return originalExports.every(exp => mockExports.includes(exp));
};

/**
 * Extracts export names from content
 */
const extractExports = (content: string): string[] => {
  const exports: string[] = [];
  const exportRegex = /export\s+(const|let|var|function|class|type|interface)\s+(\w+)/g;
  let match;

  while ((match = exportRegex.exec(content)) !== null) {
    exports.push(match[2]);
  }

  return exports;
};

/**
 * Validates mock syntax and structure
 */
const validateMockSyntax = (content: string): boolean => {
  // Check for common Jest mock patterns
  const hasJestMock = /jest\.mock/.test(content);
  const hasModuleExports = /module\.exports/.test(content);
  const hasMockImplementation = /mockImplementation/.test(content);
  
  return hasJestMock || hasModuleExports || hasMockImplementation;
};

/**
 * Validates mock dependencies
 */
const validateDependencies = (mock: MockDefinition): boolean => {
  if (!mock.dependencies) return true;
  
  return mock.dependencies.every(dep => {
    const depPath = path.resolve(path.dirname(mock.mockPath), dep);
    return fs.existsSync(depPath);
  });
};

/**
 * Extracts mock dependencies by analyzing the mock file content
 */
const extractMockDependencies = (mockContent: string): string[] => {
  const dependencies: string[] = [];
  // Look for jest.mock() calls and imports
  const mockRegex = /jest\.mock\(['"]([^'"]+)['"]\)/g;
  const importRegex = /(?:import|require)\s*\(?['"]([^'"]+)['"]\)?/g;

  let match;
  while ((match = mockRegex.exec(mockContent)) !== null) {
    dependencies.push(match[1]);
  }
  while ((match = importRegex.exec(mockContent)) !== null) {
    dependencies.push(match[1]);
  }

  return [...new Set(dependencies)]; // Remove duplicates
};

/**
 * Creates a new mock file for a module
 */
export const createMockFile = async (
  projectPath: string,
  modulePath: string,
  mockContent: string
): Promise<MockDefinition> => {
  const baseDir = setupMocksDirectory(projectPath, modulePath);

  // Handle scoped packages and local imports
  const mockRelativePath = modulePath.startsWith('.') 
    ? path.relative(projectPath, path.resolve(projectPath, modulePath))
    : modulePath;

  const mockFileName = `${path.basename(mockRelativePath, path.extname(mockRelativePath))}.mock${path.extname(mockRelativePath) || '.ts'}`;
  const mockPath = path.join(baseDir, path.dirname(mockRelativePath), mockFileName);

  // Ensure the directory exists
  fs.mkdirSync(path.dirname(mockPath), { recursive: true });

  // Write the mock file
  await fs.promises.writeFile(mockPath, mockContent, 'utf8');

  // Extract dependencies from the generated mock content
  const dependencies = extractMockDependencies(mockContent);

  return {
    modulePath,
    mockPath,
    isAutoGenerated: true,
    dependencies
  };
};

/**
 * Builds an AI prompt for mock generation
 */
const buildMockPrompt = (modulePath: string, originalContent?: string): string => {
  let prompt = `Create a Jest mock for the module '${modulePath}'.`;

  if (originalContent) {
    prompt += `\n\nOriginal module content for reference:\n\`\`\`typescript\n${originalContent}\n\`\`\``;
  }

  prompt += `\n\nRequirements:
1. Include all necessary exports
2. Provide Jest mock implementations
3. Handle async functions if present
4. Include proper TypeScript types
5. Add JSDoc comments for complex mocks`;

  return prompt;
};